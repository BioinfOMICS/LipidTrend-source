<!DOCTYPE html><html><head><title>R: Variance Stabilizing Normalization (vsn)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>normalizeVSN {limma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Variance Stabilizing Normalization (vsn)</h2>

<h3>Description</h3>

<p>Apply variance stabilizing normalization (vsn) to limma data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeVSN(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x">x</code></td>
<td>
<p>a numeric <code>matrix</code>, <code>EListRaw</code> or <code><a href="../help/rglist.html">RGList</a></code> object.</p>
</td></tr>
<tr><td><code id="...">...</code></td>
<td>
<p>other arguments are passed to <code>vsn</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an interface to the <code>vsnMatrix</code> function from the vsn package.
The input <code>x</code> should contain raw intensities.
If <code>x</code> contains background and well as foreground intensities, these will be subtracted from the foreground intensities before <code>vsnMatrix</code> is called.
</p>
<p>Note that the vsn algorithm performs background correction and normalization simultaneously.
If the data are from two-color microarrays, then the red and green intensities are treated as if they were single channel data, i.e., red and green channels from the same array are treated as unpaired.
This algorithm is therefore separate from the backgroundCorrection, normalizeWithinArrays, then normalizeBetweenArrays paradigm used elsewhere in the limma package.
</p>


<h3>Value</h3>

<p>The class of the output depends on the input.
If <code>x</code> is a matrix, then the result is a matrix of the same size.
If <code>x</code> is an <code>EListRaw</code> object, then an <code>EList</code> object with expression values on the log2 scale is produced.
For <code>x</code> is an <code>RGList</code>, then an <code><a href="../help/malist.html">MAList</a></code> object with M and A-values on the log2 scale is produced.
</p>


<h3>Author(s)</h3>

<p>Gordon Smyth</p>


<h3>References</h3>

<p>Huber, W, von Heydebreck, A, Sueltmann, H, Poustka, A, Vingron, M (2002).
Variance stabilization applied to microarray data calibration and to the quantification of differential expression.
Bioinformatics 18 Supplement 1, S96-S104.
</p>


<h3>See Also</h3>

<p>An overview of LIMMA functions for normalization is given in <a href="../../limma/help/05.Normalization.html">05.Normalization</a>.
</p>
<p>See also <code><a href="../../vsn/help/vsn2.html">vsnMatrix</a></code> in the vsn package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngenes &lt;- 100
narrays &lt;- 4
x &lt;- matrix(rnorm(ngenes*narrays),100,4)
y &lt;- normalizeVSN(x)
</code></pre>

<hr><div style="text-align: center;">[Package <em>limma</em> version 3.66.0 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
