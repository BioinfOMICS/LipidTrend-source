<!DOCTYPE html><html><head><title>R: Robust Fitting of Nonlinear Regression Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>nlrob {robustbase}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Robust Fitting of Nonlinear Regression Models</h2>

<h3>Description</h3>

<p><code>nlrob</code> fits a nonlinear regression model by robust methods.
Per default, by an M-estimator, using iterated reweighted least
squares (called &ldquo;IRLS&rdquo; or also &ldquo;IWLS&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlrob(formula, data, start, lower, upper,
      weights = NULL, na.action = na.fail,
      method = c("M", "MM", "tau", "CM", "mtl"),
      psi = .Mwgt.psi1("huber", cc=1.345), scale = NULL,
      test.vec = c("resid", "coef", "w"), maxit = 20,
      tol = 1e-06, acc, algorithm = "default", doCov = FALSE, model = FALSE,
      control = if(method == "M") nls.control() else
		nlrob.control(method, optArgs = list(trace=trace), ...),
      trace = FALSE, ...)

## S3 method for class 'nlrob'
fitted(object, ...)
## S3 method for class 'nlrob'
residuals(object, type = , ...)
## S3 method for class 'nlrob'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula">formula</code></td>
<td>
<p>a nonlinear <code><a href="../../stats/html/formula.html">formula</a></code> including variables
and parameters of the model, such as <code>y ~ f(x, theta)</code> (cf. <code><a href="../../stats/html/nls.html">nls</a></code>).
(For some checks: if <code class="reqn">f(.)</code> is linear, then we need
parentheses, e.g., <code>y ~ (a + b * x)</code>;
(note that <code>._nlrob.w</code> is not allowed as variable or parameter name))



</p>
</td></tr>
<tr><td><code id="data">data</code></td>
<td>
<p>an optional data frame containing the variables
in the model.  If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from
which <code>nlrob</code> is called.</p>
</td></tr>
<tr><td><code id="start">start</code></td>
<td>
<p>a named numeric vector of starting parameters estimates,
only for <code>method = "M"</code>.</p>
</td></tr>
<tr><td><code id="lower">lower</code>, <code id="upper">upper</code></td>
<td>
<p>numeric vectors of lower and upper bounds; if
needed, will be replicated to be as long as the longest of <code>start</code>,
<code>lower</code> or <code>upper</code>.  For (the default) <code>method = "M"</code>,
if the bounds are unspecified all parameters are assumed to be
unconstrained; also, for method <code>"M"</code>, bounds can only be used
with the <code>"port"</code> algorithm.  They are ignored, with a warning,
in cases they have no effect.
</p>
<p>For all other methods, currently these bounds <em>must</em> be
specified as finite values, and one of them must have
<code><a href="../../base/html/names.html">names</a></code> matching the parameter names in <code>formula</code>.
</p>
<p>For methods <code>"CM"</code> and <code>"mtl"</code>, the bounds must
<em>additionally</em> have an entry named <code>"sigma"</code> as that is
determined simultaneously in the same optimization, and hence its
<code>lower</code> bound must not be negative.
</p>
</td></tr>
<tr><td><code id="weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process (for intrinsic weights, not the weights <code>w</code> used in the
iterative (robust) fit). I.e.,
<code>sum(w * e^2)</code> is minimized with <code>e</code> = residuals,
<code class="reqn">e_i = y_i - f(xreg_i, \theta)</code>,
where <code class="reqn">f(x,\theta)</code> is the nonlinear function,
and <code>w</code> are the robust weights from <code>resid * weights</code>.</p>
</td></tr>
<tr><td><code id="na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default action is for the procedure to
fail.  If NAs are present, use <code>na.exclude</code> to have residuals with
<code>length == nrow(data) == length(w)</code>, where <code>w</code> are the
weights used in the iterative robust loop.  This is better if the
explanatory variables in
<code>formula</code> are time series (and so the NA location is important).
For this reason, <code>na.omit</code>, which leads to omission of cases
with missing values on any required variable, is not suitable
here since the residuals length is different from
<code>nrow(data) == length(w)</code>.
</p>
</td></tr>
<tr><td><code id="method">method</code></td>
<td>
<p>a character string specifying which method to use.  The
default is <code>"M"</code>, for historical and back-compatibility
reasons.  For the other methods, primarily see
<code><a href="../../robustbase/help/nlrob.algorithms.html">nlrob.algorithms</a></code>. 
</p>

<dl>
<dt>&quot;M&quot;</dt><dd><p>Computes an M-estimator, using <code><a href="../../stats/html/nls.html">nls</a>(*,
	  weights=*)</code> iteratively (hence, IRLS) with weights equal to
<code class="reqn">\psi(r_i) / r_i</code>, where <code class="reqn">r_i</code> is the i-the residual
from the previous fit.</p>
</dd>
<dt>&quot;MM&quot;</dt><dd><p>Computes an MM-estimator, starting from <code>init</code>,
either &quot;S&quot; or &quot;lts&quot;.</p>
</dd>
<dt>&quot;tau&quot;</dt><dd><p>Computes a Tau-estimator.</p>
</dd>
<dt>&quot;CM&quot;</dt><dd><p>Computes a &ldquo;Constrained M&rdquo; (=: CM) estimator.</p>
</dd>
<dt>&quot;mtl&quot;</dt><dd><p>Compute as &ldquo;Maximum Trimmed Likelihood&rdquo; (=: MTL)
estimator.</p>
</dd>
</dl>

<p>Note that all methods but <code>"M"</code> are &ldquo;random&rdquo;, hence
typically to be preceded by <code><a href="../../base/html/Random.html">set.seed</a>()</code> in usage, see
also <code><a href="../../robustbase/help/nlrob.algorithms.html">nlrob.algorithms</a></code>. 
</p>
</td></tr>
<tr><td><code id="psi">psi</code></td>
<td>
<p>a function (possibly by name) of the form <code>g(x, 'tuning
      constant(s)', deriv)</code> that for <code>deriv=0</code> returns
<code class="reqn">\psi(x)/x</code> and for <code>deriv=1</code> returns
<code class="reqn">\psi'(x)</code>.  Note that tuning constants can <em>not</em>
be passed separately, but directly via the specification of <code>psi</code>,
typically via a simple <code><a href="../../robustbase/help/.Mwgt.psi1.html">.Mwgt.psi1</a>()</code> call as per
default.
</p>
<p>Note that this has been a deliberately non-backcompatible change
for robustbase version 0.90-0 (summer 2013 &ndash; early 2014).
</p>
</td></tr>
<tr><td><code id="scale">scale</code></td>
<td>
<p>when not <code>NULL</code> (default), a positive number
specifying a scale kept <em>fixed</em> during the iterations (and
returned as <code>Scale</code> component).</p>
</td></tr>
<tr><td><code id="test.vec">test.vec</code></td>
<td>
<p>character string specifying the convergence
criterion. The relative change is tested for residuals with a value
of <code>"resid"</code> (the default), for coefficients with
<code>"coef"</code>, and for weights with <code>"w"</code>.</p>
</td></tr>
<tr><td><code id="maxit">maxit</code></td>
<td>
<p>maximum number of iterations in the robust loop.</p>
</td></tr>
<tr><td><code id="tol">tol</code></td>
<td>
<p>non-negative convergence tolerance for the robust fit.</p>
</td></tr>
<tr><td><code id="acc">acc</code></td>
<td>
<p>previous name for <code>tol</code>, now deprecated.</p>
</td></tr>
<tr><td><code id="algorithm">algorithm</code></td>
<td>
<p>character string specifying the algorithm to use for
<code><a href="../../stats/html/nls.html">nls</a></code>, see there, only when <code>method = "M"</code>.  The
default algorithm is a Gauss-Newton algorithm.</p>
</td></tr>
<tr><td><code id="doCov">doCov</code></td>
<td>
<p>a logical specifying if <code>nlrob()</code> should compute the
asymptotic variance-covariance matrix (see <code><a href="../../stats/html/vcov.html">vcov</a></code>)
already.  This used to be hard-wired to <code>TRUE</code>; however, the
default has been set to <code>FALSE</code>, as <code><a href="../../stats/html/vcov.html">vcov</a>(obj)</code> and
<code><a href="../../base/html/summary.html">summary</a>(obj)</code> can easily compute it when needed.</p>
</td></tr>
<tr><td><code id="model">model</code></td>
<td>
<p>a <code><a href="../../base/html/logical.html">logical</a></code> indicating if the
<code><a href="../../stats/html/model.frame.html">model.frame</a></code> should be returned as well.</p>
</td></tr>
<tr><td><code id="control">control</code></td>
<td>
<p>an optional list of control settings.
</p>

<dl>
<dt>for <code>method = "M"</code>:</dt><dd><p>settings for <code><a href="../../stats/html/nls.html">nls</a>()</code>.
See <code><a href="../../stats/html/nls.control.html">nls.control</a></code> for the names of the settable control
values and their effect.</p>
</dd>
<dt>for all <code>method</code>s but <code>"M"</code>:</dt><dd><p>a list, typically
resulting from <code><a href="../../robustbase/help/nlrob.control.html">nlrob.control</a>(method, *)</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="trace">trace</code></td>
<td>
<p>logical value indicating if a &ldquo;trace&rdquo; of
the <code>nls</code> iteration progress should be printed.  Default is
<code>FALSE</code>. <br>
If <code>TRUE</code>, in each robust iteration, the residual
sum-of-squares and the parameter values are printed at the
conclusion of each <code>nls</code> iteration.
When the <code>"plinear"</code> algorithm is used, the conditional
estimates of the linear parameters are printed after the nonlinear
parameters.</p>
</td></tr>
<tr><td><code id="object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"nlrob"</code>, typically
resulting from <code>nlrob(..)</code>.</p>
</td></tr>
<tr><td><code id="...">...</code></td>
<td>
<p>for <code>nlrob</code>: only when <code>method</code> is <em>not</em> <code>"M"</code>,
optional arguments for <code><a href="../../robustbase/help/nlrob.control.html">nlrob.control</a></code>;
<br>
for other functions: potentially optional arguments passed to the
extractor methods.</p>
</td></tr>
<tr><td><code id="type">type</code></td>
<td>
<p>a string specifying the <em>type</em> of residuals desired.
Currently, <code>"response"</code> and <code>"working"</code> are supported.

</p>
</td></tr>
<tr><td><code id="newdata">newdata</code></td>
<td>
<p>a data frame (or list) with the same names as the
original <code>data</code>, see e.g., <code><a href="../../stats/html/predict.nls.html">predict.nls</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method = "M"</code>, iterated reweighted least squares
(&ldquo;IRLS&rdquo; or &ldquo;IWLS&rdquo;) is used, calling <code><a href="../../stats/html/nls.html">nls</a>(*,
    weights= .)</code> where <code>weights</code> <code class="reqn">w_i</code> are proportional to
<code class="reqn">\psi(r_i/ \hat{\sigma})</code>.
</p>
<p>All other methods minimize differently, and work <b>without</b>
<code><a href="../../stats/html/nls.html">nls</a></code>.  See <a href="../../robustbase/help/nlrob.algorithms.html">nlrob.algorithms</a> 
for details.
</p>


<h3>Value</h3>

<p><code>nlrob()</code> returns an object of S3 class <code>"nlrob"</code>,
for <code>method = "M"</code> also inheriting from class <code>"nls"</code>, (see
<code><a href="../../stats/html/nls.html">nls</a></code>).
</p>
<p>It is a list with several components; they are not documented yet,
as some of them will probably change.
Instead, rather use &ldquo;accessor&rdquo; methods, where possible:
There are methods (at least) for the generic accessor functions
<code><a href="../../base/html/summary.html">summary</a>()</code>, <code><a href="../../stats/html/coef.html">coefficients</a>()</code> (aka <code>coef()</code>)
<code>fitted.values()</code>, <code>residuals()</code>, <code><a href="../../robustbase/help/sigma.html">sigma</a>()</code> and
<code><a href="../../stats/html/vcov.html">vcov</a>()</code>, the latter for the variance-covariance matrix of
the estimated parameters, as returned by <code>coef()</code>, i.e., not
including the variance of the errors.
For <code>nlrob()</code> results, <code><a href="../../robustbase/help/estimethod.html">estimethod</a>()</code> returns the
&ldquo;estimation method&rdquo;, which coincides with the <code>method</code>
argument used.
</p>
<p><code>residuals(.)</code>, by default <code>type = "response"</code>, returns
the residuals <code class="reqn">e_i</code>, defined above as
<code class="reqn">e_i = Y_i - f_(x_i, \hat\theta)</code>.
These differ from the standardized or weighted residuals which, e.g.,
are assumed to be normally distributed, and a version of which is
returned in <code>working.residuals</code> component.

</p>


<h3>Note</h3>

<p>This function (with the only method <code>"M"</code>) used to be named
<code>rnls</code> and has been in package <a href="https://CRAN.R-project.org/package=sfsmisc"><span class="pkg">sfsmisc</span></a> in the past, but
been dropped there.
</p>


<h3>Author(s)</h3>


<dl>
<dt><code>method = "M"</code>:</dt><dd>
<p>Andreas Ruckstuhl (inspired by <code><a href="../../MASS/help/rlm.html">rlm</a></code>() and
<code><a href="../../stats/html/nls.html">nls</a></code>()), in July 1994 for S-plus.<br>
Christian Sangiorgio did the update to <span class="rlang"><b>R</b></span> and corrected some errors,
from June 2002 to January 2005, and Andreas contributed slight changes
and the first methods in August 2005.</p>
</dd>
<dt><code>method = "MM"</code>, etc:</dt><dd><p>Originally all by Eduardo
L. T. Conceicao, see <code><a href="../../robustbase/help/nlrob.algorithms.html">nlrob.algorithms</a></code>:</p>
</dd> 
</dl>

<p>Since then, the help page, testing, more cleanup, new methods: Martin
Maechler.
</p>


<h3>See Also</h3>

 <p><code><a href="../../stats/html/nls.html">nls</a></code>, <code><a href="../../MASS/help/rlm.html">rlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNase1 &lt;- DNase[ DNase$Run == 1, ]

## note that selfstarting models don't work yet % &lt;&lt;&lt; FIXME !!!

##--- without conditional linearity ---

## classical
fmNase1 &lt;- nls( density ~ Asym/(1 + exp(( xmid - log(conc) )/scal ) ),
                data = DNase1,
                start = list( Asym = 3, xmid = 0, scal = 1 ),
                trace = TRUE )
summary( fmNase1 )

## robust
RmN1  &lt;- nlrob( density ~ Asym/(1 + exp(( xmid - log(conc) )/scal ) ),
                data = DNase1, trace = TRUE,
                start = list( Asym = 3, xmid = 0, scal = 1 ))
summary( RmN1 )

##--- using conditional linearity ---

## classical
fm2DNase1 &lt;- nls( density ~ 1/(1 + exp(( xmid - log(conc) )/scal ) ),
                  data = DNase1,
                  start = c( xmid = 0, scal = 1 ),
                  alg = "plinear", trace = TRUE )
summary( fm2DNase1 )

## robust
frm2DNase1 &lt;- nlrob(density ~ 1/(1 + exp(( xmid - log(conc) )/scal ) ),
                  data = DNase1, start = c( xmid = 0, scal = 1 ),
                  alg = "plinear", trace = TRUE )
summary( frm2DNase1 )
## Confidence for linear parameter is quite smaller than "Asym" above
c1 &lt;- coef(summary(RmN1))
c2 &lt;- coef(summary(frm2DNase1))
rownames(c2)[rownames(c2) == ".lin"] &lt;- "Asym"
stopifnot(all.equal(c1[,1:2], c2[rownames(c1), 1:2], tol = 0.09)) # 0.07315

### -- new examples -- "moderate outlier":
DN2 &lt;- DNase1
DN2[10,"density"] &lt;- 2*DN2[10,"density"]

fm3DN2 &lt;- nls(density ~  Asym/(1 + exp(( xmid - log(conc) )/scal ) ),
              data = DN2, trace = TRUE,
              start = list( Asym = 3, xmid = 0, scal = 1 ))

## robust
Rm3DN2 &lt;- nlrob(density ~  Asym/(1 + exp(( xmid - log(conc) )/scal ) ),
                data = DN2, trace = TRUE,
                start = list( Asym = 3, xmid = 0, scal = 1 ))
Rm3DN2
summary(Rm3DN2) # -&gt; robustness weight of obs. 10 ~= 0.037
confint(Rm3DN2, method = "Wald")
stopifnot(identical(Rm3DN2$dataClasses,
                    c(density = "numeric", conc = "numeric")))

## utility function sfsmisc::lseq() :
lseq &lt;- function (from, to, length)
  2^seq(log2(from), log2(to), length.out = length)
## predict() {and plot}:
h.x &lt;- lseq(min(DN2$conc), max(DN2$conc), length = 100)
nDat &lt;- data.frame(conc = h.x)

h.p  &lt;- predict(fm3DN2, newdata = nDat)# classical
h.rp &lt;- predict(Rm3DN2, newdata = nDat)# robust

plot(density ~ conc, data=DN2, log="x",
     main = format(formula(Rm3DN2)))
lines(h.x, h.p,  col="blue")
lines(h.x, h.rp, col="magenta")
legend("topleft", c("classical nls()", "robust nlrob()"),
       lwd = 1, col= c("blue", "magenta"), inset = 0.05)

## See  ?nlrob.algorithms for examples

DNase1 &lt;- DNase[DNase$Run == 1,]
form &lt;- density ~ Asym/(1 + exp(( xmid -log(conc) )/scal ))
gMM  &lt;- nlrob(form, data = DNase1, method = "MM",
              lower = c(Asym = 0, xmid = 0, scal = 0),
              upper = 3, trace = TRUE)

## "CM" (and "mtl") additionally need bounds for "sigma" :
gCM  &lt;- nlrob(form, data = DNase1, method = "CM",
              lower = c(Asym = 0, xmid = 0, scal = 0, sigma = 0),
              upper = c(3,3,3, sigma = 0.8))
summary(gCM)# did fail; note it has  NA NA NA (std.err, t val, P val)
stopifnot(identical(Rm3DN2$dataClasses, gMM$dataClasses),
          identical(   gCM$dataClasses, gMM$dataClasses))

</code></pre>

<hr><div style="text-align: center;">[Package <em>robustbase</em> version 0.99-7 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
