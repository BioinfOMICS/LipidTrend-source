<!DOCTYPE html><html><head><title>R: Medcouple, a Robust Measure of Skewness</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>mc {robustbase}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Medcouple, a Robust Measure of Skewness</h2>

<h3>Description</h3>

<p>Compute the &lsquo;medcouple&rsquo;, a <em>robust</em> concept and estimator
of skewness.  The medcouple is defined as a scaled median difference
of the left and right half of distribution, and hence <em>not</em> based
on the third moment as the classical skewness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc(x, na.rm = FALSE, doReflect = (length(x) &lt;= 100),
   doScale = FALSE,     # was hardwired=TRUE, then default=TRUE
   c.huberize = 1e11,   # was implicitly = Inf originally
   eps1 = 1e-14, eps2 = 1e-15,   # &lt;&lt; new in 0.93-2 (2018-07..)
   maxit = 100, trace.lev = 0, full.result = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="na.rm">na.rm</code></td>
<td>
<p>logical indicating how missing values (<code><a href="../../base/html/NA.html">NA</a></code>s)
should be dealt with.</p>
</td></tr>
<tr><td><code id="doReflect">doReflect</code></td>
<td>
<p>logical indicating if the internal MC should also be
computed on the <em>reflected</em> sample <code>-x</code>, with final result
<code>(mc.(x) - mc.(-x))/2</code>.  This makes sense since the internal
MC, <code>mc.()</code> computes the himedian() which can differ slightly from
the median.</p>
</td></tr>
<tr><td><code id="doScale">doScale</code></td>
<td>
<p>logical indicating if the internal algorithm should
also <em>scale</em> the data (using the most distant value from the
median which is unrobust and numerically dangerous); scaling has been
hardwired in the original algorithm and <span class="rlang"><b>R</b></span>'s <code>mc()</code> till summer
2018, where it became the default.  Since <span class="pkg">robustbase</span> version 0.95-0,
March 2022, the default is <code>FALSE</code>.  As this may change the
result, a message is printed about the new default, once per <span class="rlang"><b>R</b></span>
session.  You can suppress the message by specifying <code>doScale = *</code>
explicitly, or, by setting <code><a href="../../base/html/options.html">options</a>(mc_doScale_quiet=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="c.huberize">c.huberize</code></td>
<td>
<p>a positive number (default: <code>1e11</code>) used to
stabilize the sample via <code>x &lt;- <a href="../../robustbase/help/huberize.html">huberize</a>(x, c = c.huberize)</code>
for the <code>mc()</code> computations in the case of a nearly degenerate
sample (many observations practically equal to the median) or very
extreme outliers.  In previous versions of <span class="pkg">robustbase</span> no such
huberization was applied which is equivalent to <code>c.huberize = Inf</code>.</p>
</td></tr>
<tr><td><code id="eps1">eps1</code>, <code id="eps2">eps2</code></td>
<td>
<p>tolerance in the algorithm; <code>eps1</code> is used as a  for
convergence tolerance, where <code>eps2</code> is only used in the internal
<code>h_kern()</code> function to prevent underflow to zero, so could be
considerably smaller.  The original code implicitly <em>hard
coded</em> in C <code>eps1 := eps2 := 1e-13</code>;  only change with care!</p>
</td></tr>
<tr><td><code id="maxit">maxit</code></td>
<td>
<p>maximal number of iterations; typically a few should be
sufficient.</p>
</td></tr>
<tr><td><code id="trace.lev">trace.lev</code></td>
<td>
<p>integer specifying how much diagnostic output the
algorithm (in C) should produce.  No output by default, most output
for <code>trace.lev = 5</code>.</p>
</td></tr>
<tr><td><code id="full.result">full.result</code></td>
<td>
<p>logical indicating if the full return values (from
C) should be returned as a list via <code>attr(*, "mcComp")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number between -1 and 1, which is the medcouple, <code class="reqn">MC(x)</code>.
For <code>r &lt;- mc(x, full.result = TRUE, ....)</code>, then
<code>attr(r, "mcComp")</code> is a list with components
</p>
<table role = "presentation">
<tr><td><code>medc</code></td>
<td>
<p>the medcouple  <code class="reqn">mc.(x)</code>.</p>
</td></tr>
<tr><td><code>medc2</code></td>
<td>
<p>the medcouple <code class="reqn">mc.(-x)</code> if <code>doReflect=TRUE</code>.</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>tolerances used.</p>
</td></tr>
<tr><td><code>iter</code>, <code>iter2</code></td>
<td>
<p>number of iterations used.</p>
</td></tr>
<tr><td><code>converged</code>, <code>converged2</code></td>
<td>
<p>logical specifying &ldquo;convergence&rdquo;.</p>
</td></tr>
</table>


<h3>Convergence Problems</h3>

<p>For extreme cases there were convergence problems which should not
happen anymore as we now use <code>doScale=FALSE</code> and huberization (when
<code>c.huberize &lt; Inf</code>).
</p>



<p>The original algorithm and <code>mc(*, doScale=TRUE)</code> not only centers
the data around the median but
also scales them by the extremes which may have a negative effect
e.g., when changing an extreme outlier to even more extreme, the
result changes wrongly; see the 'mc10x' example.
</p>


<h3>Author(s)</h3>

<p>Guy Brys; modifications by Tobias Verbeke and bug fixes and
extensions by Manuel Koller and Martin Maechler.
</p>
<p>The new default <code>doScale=FALSE</code>, and the new <code>c.huberize</code> were
introduced as consequence of Lukas Graz' BSc thesis.
</p>


<h3>References</h3>

<p>Guy Brys, Mia Hubert and Anja Struyf (2004)
A Robust Measure of Skewness;
<em>JCGS</em> <b>13</b> (4), 996&ndash;1017.
</p>
<p>Hubert, M. and Vandervieren, E. (2008).
An adjusted boxplot for skewed distributions,
<em>Computational Statistics and Data Analysis</em> <b>52</b>, 5186&ndash;5201.
</p>
<p>Lukas Graz (2021). Improvement of the Algorithms for the Medcoule and the
Adjusted Outlyingness; unpublished BSc thesis, supervised by M.Maechler, ETH Zurich.
</p>


<h3>See Also</h3>

<p><code><a href="../../robustbase/help/Qn.html">Qn</a></code> for a robust measure of scale (aka
&ldquo;dispersion&rdquo;), ....
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc(1:5) # 0 for a symmetric sample

x1 &lt;- c(1, 2, 7, 9, 10)
mc(x1) # = -1/3

data(cushny)
mc(cushny) # 0.125

stopifnot(mc(c(-20, -5, -2:2, 5, 20)) == 0,
          mc(x1, doReflect=FALSE) ==  -mc(-x1, doReflect=FALSE),
          all.equal(mc(x1, doReflect=FALSE), -1/3, tolerance = 1e-12))

## Susceptibility of the current algorithm to large outliers :
dX10 &lt;- function(X) c(1:5,7,10,15,25, X) # generate skewed size-10 with 'X'
x &lt;- c(10,20,30, 100^(1:20))
## (doScale=TRUE, c.huberize=Inf)  were (implicit) defaults in earlier {robustbase}:
(mc10x &lt;- vapply(x, function(X) mc(dX10(X), doScale=TRUE, c.huberize=Inf), 1))
## limit X -&gt; Inf  should be 7/12 = 0.58333...  but that "breaks down a bit" :
plot(x, mc10x, type="b", main = "mc( c(1:5,7,10,15,25, X) )", xlab="X", log="x")
## The new behavior is much preferable {shows message about new 'doScale=FALSE'}:
(mc10N &lt;- vapply(x, function(X) mc(dX10(X)), 1))
lines(x, mc10N, col=adjustcolor(2, 3/4), lwd=3)
mtext("mc(*, c.huberize=1e11)",  col=2)
stopifnot(all.equal(c(4, 6, rep(7, length(x)-2))/12, mc10N))
## Here, huberization already solves the issue:
mc10NS &lt;- vapply(x, function(X) mc(dX10(X), doScale=TRUE), 1)
stopifnot(all.equal(mc10N, mc10NS))
</code></pre>

<hr><div style="text-align: center;">[Package <em>robustbase</em> version 0.99-7 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
