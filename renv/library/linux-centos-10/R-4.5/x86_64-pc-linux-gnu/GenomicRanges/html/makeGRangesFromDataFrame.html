<!DOCTYPE html><html><head><title>R: Make a GRanges object from a data.frame or DataFrame</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>makeGRangesFromDataFrame {GenomicRanges}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Make a GRanges object from a data.frame or DataFrame</h2>

<h3>Description</h3>

<p><code>makeGRangesFromDataFrame</code> and <code>makeGPosFromDataFrame</code> both
take a data-frame-like object as input and try to automatically find the
columns that describe genomic ranges (for <code>makeGRangesFromDataFrame</code>)
or genomic positions (for <code>makeGPosFromDataFrame</code>).
If successful, they return them in a <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> or <a href="../../GenomicRanges/help/GPos.html">GPos</a> object.
</p>
<p>The two functions are also the workhorses behind the coercion methods from
data.frame (or <a href="../../S4Vectors/help/DataFrame.html">DataFrame</a>) to <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> or <a href="../../GenomicRanges/help/GPos.html">GPos</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGRangesFromDataFrame(df, keep.extra.columns=FALSE,
        ignore.strand=FALSE, seqinfo=NULL,
        seqnames.field=c("seqnames", "seqname",
                         "chromosome", "chrom", "chr", "chromosome_name",
                         "seqid"),
        start.field="start",
        end.field=c("end", "stop"),
        strand.field="strand",
        starts.in.df.are.0based=FALSE,
        na.rm=FALSE)

makeGPosFromDataFrame(df, keep.extra.columns=FALSE,
        ignore.strand=FALSE, seqinfo=NULL,
        seqnames.field=c("seqnames", "seqname",
                         "chromosome", "chrom", "chr", "chromosome_name",
                         "seqid"),
        pos.field=c("pos", "position", "positions"),
        strand.field="strand",
        na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df">df</code></td>
<td>

<p>A data.frame or <a href="../../S4Vectors/help/DataFrame.html">DataFrame</a> object. If not, then
the function first tries to turn <code>df</code> into a data frame with
<code>as.data.frame(df)</code>.
</p>
</td></tr>
<tr><td><code id="keep.extra.columns">keep.extra.columns</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
If <code>TRUE</code>, then the columns in <code>df</code> that are not used to form
the genomic ranges or genomic positions of the returned <a href="../../GenomicRanges/help/GRanges.html">GRanges</a>
or <a href="../../GenomicRanges/help/GPos.html">GPos</a> object are returned as metadata columns on the object.
Otherwise, they are ignored.
</p>
<p>Note that if <code>df</code> has a <code>width</code> column, then
<code>makeGRangesFromDataFrame</code> will always ignore it.
</p>
</td></tr>
<tr><td><code id="ignore.strand">ignore.strand</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
If <code>TRUE</code>, then the strand of the returned <a href="../../GenomicRanges/help/GRanges.html">GRanges</a>
or <a href="../../GenomicRanges/help/GPos.html">GPos</a> object is set to <code>"*"</code>.
</p>
</td></tr>
<tr><td><code id="seqinfo">seqinfo</code></td>
<td>

<p>Either <code>NULL</code>, or a <a href="../../Seqinfo/help/Seqinfo.html">Seqinfo</a> object,
or a character vector of unique sequence names (a.k.a. <em>seqlevels</em>),
or a named numeric vector of sequence lengths.
When not <code>NULL</code>, <code>seqinfo</code> must be compatible with the genomic
ranges in <code>df</code>, that is, it must have one entry for each unique
sequence name represented in <code>df</code>. Note that it can have additional
entries i.e. entries for seqlevels not represented in <code>df</code>.
</p>
</td></tr>
<tr><td><code id="seqnames.field">seqnames.field</code></td>
<td>

<p>A character vector of recognized names for the column in <code>df</code>
that contains the chromosome name (a.k.a. sequence name) associated
with each genomic range.
Only the first name in <code>seqnames.field</code> that is found
in <code>colnames(df)</code> is used.
If no one is found, then an error is raised.
</p>
</td></tr>
<tr><td><code id="start.field">start.field</code></td>
<td>

<p>A character vector of recognized names for the column in <code>df</code>
that contains the start positions of the genomic ranges.
Only the first name in <code>start.field</code> that is found
in <code>colnames(df)</code> is used.
If no one is found, then an error is raised.
</p>
</td></tr>
<tr><td><code id="end.field">end.field</code></td>
<td>

<p>A character vector of recognized names for the column in <code>df</code>
that contains the end positions of the genomic ranges.
Only the first name in <code>start.field</code> that is found
in <code>colnames(df)</code> is used.
If no one is found, then an error is raised.
</p>
</td></tr>
<tr><td><code id="pos.field">pos.field</code></td>
<td>

<p>A character vector of recognized names for the column in <code>df</code>
that contains the genomic positions to use to make the <a href="../../GenomicRanges/help/GPos.html">GPos</a> object.
Only the first name in <code>pos.field</code> that is found
in <code>colnames(df)</code> is used.
If no one is found, then an error is raised.
</p>
</td></tr>
<tr><td><code id="strand.field">strand.field</code></td>
<td>

<p>A character vector of recognized names for the column in <code>df</code>
that contains the strand associated with each genomic range.
Only the first name in <code>strand.field</code> that is found
in <code>colnames(df)</code> is used.
If no one is found or if <code>ignore.strand</code> is <code>TRUE</code>,
then the strand of the returned <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> object is
set to <code>"*"</code>.
</p>
</td></tr>
<tr><td><code id="starts.in.df.are.0based">starts.in.df.are.0based</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
If <code>TRUE</code>, then the start positions of the genomic ranges in
<code>df</code> are considered to be <em>0-based</em> and are converted to
<em>1-based</em> in the returned <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> object.
This feature is intended to make it more convenient to handle input
that contains data obtained from resources using the &quot;0-based
start&quot; convention. A notorious example of such resource is the UCSC
Table Browser (<a href="http://genome.ucsc.edu/cgi-bin/hgTables">http://genome.ucsc.edu/cgi-bin/hgTables</a>).
</p>
</td></tr>
<tr><td><code id="na.rm">na.rm</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> (the default).
</p>
<p>If <code>TRUE</code>, then rows in the <code>df</code> with missing start, end,
or position values (i.e. the value is <code>NA</code>) are ignored.
Otherwise, they trigger an error.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> or <a href="../../GenomicRanges/help/GPos.html">GPos</a> object.
</p>
<p>If <code>na.rm</code> is set to <code>FALSE</code> (the default), then the
returned object is guaranteed to have one element per row in the input.
However, if <code>na.rm</code> is set to <code>TRUE</code>, then the length of the
returned object can be less than <code>nrow(df)</code>.
</p>
<p>If the <code>seqinfo</code> argument was supplied, the returned object will
have exactly the seqlevels specified in <code>seqinfo</code> and in the same
order. Otherwise, the seqlevels are ordered according to the output of
the <code><a href="../../Seqinfo/help/rankSeqlevels.html">rankSeqlevels</a></code> function (except if
<code>df</code> contains the seqnames in the form of a factor or factor-Rle,
in which case the <code>levels()</code> of the seqnames become the seqlevels
of the returned object as-is, that is, without any re-ordering).
</p>
<p>If <code>df</code> has non-automatic row names (i.e. <code>rownames(df)</code> is
not <code>NULL</code> and is not <code>seq_len(nrow(df))</code>), then they will be
used to set names on the returned <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> or <a href="../../GenomicRanges/help/GPos.html">GPos</a> object.
</p>


<h3>Note</h3>

<p>Coercing a data.frame or <a href="../../S4Vectors/help/DataFrame.html">DataFrame</a> <code>df</code>
to <a href="../../GenomicRanges/help/GRanges.html">GRanges</a> (with <code>as(df, "GRanges")</code>), or calling
<code>GRanges(df)</code>, are both equivalent to calling
<code>makeGRangesFromDataFrame(df, keep.extra.columns=TRUE)</code>.
</p>
<p>Coercing a data.frame or <a href="../../S4Vectors/help/DataFrame.html">DataFrame</a> <code>df</code>
to <a href="../../GenomicRanges/help/GPos.html">GPos</a> (with <code>as(df, "GPos")</code>) is equivalent to calling
<code>makeGPosFromDataFrame(df, keep.extra.columns=TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>H. Pag√®s, based on a proposal by Kasper Daniel Hansen
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="../../GenomicRanges/help/GRanges.html">GRanges</a> and <a href="../../GenomicRanges/help/GPos.html">GPos</a> objects.
</p>
</li>
<li> <p><a href="../../Seqinfo/help/Seqinfo.html">Seqinfo</a> objects and the
<code><a href="../../Seqinfo/help/rankSeqlevels.html">rankSeqlevels</a></code> function in the
<span class="pkg">Seqinfo</span> package.
</p>
</li>
<li><p> The <code><a href="../../GenomicRanges/help/makeGRangesListFromFeatureFragments.html">makeGRangesListFromFeatureFragments</a></code> function
for making a <a href="../../GenomicRanges/help/GRangesList.html">GRangesList</a> object from a list of fragmented
features.
</p>
</li>
<li> <p><code><a href="../../IRanges/help/makeIRangesFromDataFrame.html">makeIRangesFromDataFrame</a></code> in the
<span class="pkg">IRanges</span> package to make an <a href="../../IRanges/help/IRanges.html">IRanges</a>
object from a data.frame or <a href="../../S4Vectors/help/DataFrame.html">DataFrame</a>.
</p>
</li>
<li> <p><a href="../../S4Vectors/help/DataFrame.html">DataFrame</a> objects in the <span class="pkg">S4Vectors</span> package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------------------
## BASIC makeGRangesFromDataFrame() EXAMPLES
## ---------------------------------------------------------------------

df &lt;- data.frame(chr="chr1", start=11:15, end=12:16,
                 strand=c("+","-","+","*","."), score=1:5)
df
makeGRangesFromDataFrame(df)  # strand value "." is replaced with "*"

## With NAs in range-defining columns:
df$start[5] &lt;- df$end[2] &lt;- NA
df
#makeGRangesFromDataFrame(df)  # error!
makeGRangesFromDataFrame(df, na.rm=TRUE)  # rows with NAs got dropped

## The strand column is optional:
df &lt;- data.frame(chr="chr1", start=11:15, end=12:16, score=1:5)
makeGRangesFromDataFrame(df)

gr &lt;- makeGRangesFromDataFrame(df, keep.extra.columns=TRUE)
gr2 &lt;- as(df, "GRanges")  # equivalent to the above
stopifnot(identical(gr, gr2))
gr2 &lt;- GRanges(df)        # equivalent to the above
stopifnot(identical(gr, gr2))

makeGRangesFromDataFrame(df, ignore.strand=TRUE)
makeGRangesFromDataFrame(df, keep.extra.columns=TRUE,
                             ignore.strand=TRUE)

makeGRangesFromDataFrame(df, seqinfo=paste0("chr", 4:1))
makeGRangesFromDataFrame(df, seqinfo=c(chrM=NA, chr1=500, chrX=100))
makeGRangesFromDataFrame(df, seqinfo=Seqinfo(paste0("chr", 4:1)))

## ---------------------------------------------------------------------
## BASIC makeGPosFromDataFrame() EXAMPLES
## ---------------------------------------------------------------------

df &lt;- data.frame(
    rsids=    c("rs7927381", "rs79273813", "rs79273815",
                "rs79273819", "rs79273817", "rs79273811", "rs79273814"),
    seqnames= c("11", "1", "11", "1", "5", "8", "8"),
    positions=c("67579271", "179599437", "70746832",
                "5066529", "107006951", "95077418", "43582071"),
    alleles=  c("T/C", "A/G", "C/G, C/T", "G/A, G/C", "T/C, T/G",
                "G/A, G/T", "G/A, G/T"),
    genes=    c(NA, "TDRD5", "SHANK2", NA, "LOC102467213", "NDUFAF6", NA),
    row.names=letters[1:7]
)

makeGPosFromDataFrame(df)
makeGPosFromDataFrame(df, keep.extra.columns=TRUE)
as(df, "GPos")  # same as above

## With missing positions:
df$positions[2L] &lt;- NA
df
#makeGPosFromDataFrame(df)  # error!
makeGPosFromDataFrame(df, na.rm=TRUE)  # rows with NAs got dropped

## ---------------------------------------------------------------------
## ABOUT AUTOMATIC DETECTION OF THE seqnames/start/end/strand COLUMNS
## ---------------------------------------------------------------------

## Automatic detection of the seqnames/start/end/strand columns is
## case insensitive:
df &lt;- data.frame(ChRoM="chr1", StarT=11:15, stoP=12:16,
                 STRAND=c("+","-","+","*","."), score=1:5)
makeGRangesFromDataFrame(df)

## It also ignores a common prefix between the start and end columns:
df &lt;- data.frame(seqnames="chr1", tx_start=11:15, tx_end=12:16,
                 strand=c("+","-","+","*","."), score=1:5)
makeGRangesFromDataFrame(df)

## The common prefix between the start and end columns is used to
## disambiguate between more than one seqnames column:
df &lt;- data.frame(chrom="chr1", tx_start=11:15, tx_end=12:16,
                 tx_chr="chr2", score=1:5)
makeGRangesFromDataFrame(df)

## ---------------------------------------------------------------------
## 0-BASED VS 1-BASED START POSITIONS
## ---------------------------------------------------------------------

if (require(UCSC.utils)) {
  ## Use list_UCSC_tracks() to lookup the primary table associated with
  ## a given track:
  subset(list_UCSC_tracks("sacCer2"), track=="Assembly")

  df &lt;- fetch_UCSC_track_data("sacCer2", primary_table="gold")
  head(df)

  ## A common pitfall is to forget that UCSC uses the "0-based start"
  ## convention to store genomic ranges in their databases:
  gr0 &lt;- makeGRangesFromDataFrame(df, keep.extra.columns=TRUE,
                                      start.field="chromStart",
                                      end.field="chromEnd")
  head(gr0)

  ## The start positions need to be converted into 1-based positions,
  ## to adhere to the convention used in Bioconductor:
  gr1 &lt;- makeGRangesFromDataFrame(df, keep.extra.columns=TRUE,
                                      start.field="chromStart",
                                      end.field="chromEnd",
                                      starts.in.df.are.0based=TRUE)
  head(gr1)

  ## IMPORTANT NOTE: The start positions in the "fragStart" metadata
  ## column are still 0-based! That's because using
  ## 'keep.extra.columns=TRUE' only takes care of converting the
  ## start positions of the genomic ranges that define the GRanges
  ## object itself, but it doesn't meddle with its metadata columns.
}
</code></pre>

<hr><div style="text-align: center;">[Package <em>GenomicRanges</em> version 1.62.1 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
