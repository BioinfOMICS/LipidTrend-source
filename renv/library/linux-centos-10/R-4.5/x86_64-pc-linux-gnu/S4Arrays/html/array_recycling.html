<!DOCTYPE html><html><head><title>R: Multidimensional array recycling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>array_recycling {S4Arrays}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Multidimensional array recycling</h2>

<h3>Description</h3>

<p>In base R, arithmetic and other binary operations between a matrix or
array and a vector don't let the user control how the latter should
be recycled: it's always recycled along the first dimension of the
matrix or array. This has led users to use various tricks when they
need recycling along the second dimension (a.k.a. &quot;horizontal recycling&quot;),
like the popular &quot;double-transposition&quot; trick: <code>t(t(m) / colSums(m))</code>.
However this is not only inelegant, it's also inefficient.
</p>
<p><code>as_tile()</code> is meant to address that.
</p>
<p>It also allows arithmetic and other binary operations between two arrays
of distinct dimensions (rejected as &quot;non-conformable&quot; by arithmetic
operations in base R), typically between a small one (the tile) and
a bigger one, as long as their geometries are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tile(x, along=1L, dim=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x">x</code></td>
<td>

<p>An array-like object or a vector.
</p>
</td></tr>
<tr><td><code id="along">along</code></td>
<td>

<p>Can only be used when <code>x</code> is a vector.
Must be a single positive integer indicating the &quot;orientation&quot; of the
tile to be created, that is, the dimension along which <code>x</code> will be
recycled by arithmetic operations and other binary operations.
</p>
</td></tr>
<tr><td><code id="dim">dim</code></td>
<td>

<p><code>NULL</code> or the dimensions (supplied as an integer vector) of
the tile to be created.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tile object (tile is an extension of array).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>base::<a href="../../base/html/colSums.html">colSums</a></code> in the <span class="pkg">base</span> package.
</p>
</li>
<li> <p><a href="../../base/help/array.html">array</a> and <a href="../../base/help/matrix.html">matrix</a> objects in base R.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------------------
## 2D EXAMPLES
## ---------------------------------------------------------------------
m0 &lt;- matrix(1:54, nrow=6)
x &lt;- c(-1, 0, 100)

## Arithmetic operations in base R recycle 'x' along the first dimension
## of the matrix ("vertical recycling"):
m0 * x

## To recycle 'x' along the second dimension of the matrix ("horizontal
## recycling"), we turn it into an "horizontal" tile:
t &lt;- as_tile(x, along=2)
t

m0 * t

## The above produces the same result as the double-transposition trick
## but is more efficient (and also makes code easier to read):
stopifnot(identical(m0 * t, t(t(m0) * x)))

## A less artificial example:
cs0 &lt;- colSums(m0)
m &lt;- m0 / as_tile(cs0, along=2)

stopifnot(all.equal(colSums(m), rep(1, ncol(m))))  # sanity check

## Using an arbitrary 2D tile:

t &lt;- m0[1:2, 1:3]
t
## Unfortunately arithmetic operations in base R refuse to operate on
## arrays that don't have the same dimensions:
## Not run: 
  m0 / t  # ERROR! (non-conformable arrays)

## End(Not run)

## Wrapping 't' in a tile object makes this work:
m0 / as_tile(t)

## ---------------------------------------------------------------------
## 3D EXAMPLES
## ---------------------------------------------------------------------
## Note that colSums() supports multidimensional arrays. In this case
## the user can use the 'dims' argument to control how the array should
## be sliced into "columns". See '?base::colSums' for the details.

a &lt;- array(runif(300), dim=c(10, 5, 6))

## Using 'dims=2' indicates that the columns are the 2D slices obtained
## by slicing the array along its 3rd dimension. With this slicing, each
## column is a 10 x 5 matrix.
cs2 &lt;- colSums(a, dims=2)
cs2  # vector of length 6 (one value per 2D slice)

t &lt;- as_tile(cs2, along=3)
a / t

stopifnot(all.equal(colSums(a / t, dims=2), rep(1, 6)))  # sanity check

## By default (i.e. when 'dims=1') the array is considered to be made
## of 5*6 columns of length 10.
cs1 &lt;- colSums(a)
cs1  # 5 x 6 matrix

t &lt;- as_tile(cs1, dim=c(1L, dim(cs1)))
a / t

## Sanity check:
stopifnot(all.equal(colSums(a / t), matrix(1, nrow=5, ncol=6)))
</code></pre>

<hr><div style="text-align: center;">[Package <em>S4Arrays</em> version 1.10.1 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
