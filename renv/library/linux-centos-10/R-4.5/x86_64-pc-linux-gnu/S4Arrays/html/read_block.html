<!DOCTYPE html><html><head><title>R: Read array blocks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>read_block {S4Arrays}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Read array blocks</h2>

<h3>Description</h3>

<p>Use <code>read_block</code> to read a block of data from an array-like object.
</p>
<p>Note that this function is typically used in the context of block processing
of on-disk objects (e.g. <a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> objects), often
in combination with <code><a href="../../S4Arrays/help/write_block.html">write_block</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_block(x, viewport, as.sparse=NA)

## Internal generic function used by read_block() when is_sparse(x)
## is FALSE:
read_block_as_dense(x, viewport)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="x">x</code></td>
<td>

<p>An array-like object.
</p>
<p>This can be an ordinary array, a <a href="../../SparseArray/help/SparseArray.html">SparseArray</a>
object from the <span class="pkg">SparseArray</span> package, a dgCMatrix
object from the <span class="pkg">Matrix</span> package, a <a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a>
object from the <span class="pkg">DelayedArray</span> package, or any object with an array
semantic (i.e. an object for which <code>dim(x)</code> is not <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="viewport">viewport</code></td>
<td>

<p>An <a href="../../S4Arrays/help/ArrayViewport.html">ArrayViewport</a> object compatible with <code>x</code>, that is,
such that <code>refdim(viewport)</code> is identical to <code>dim(x)</code>.
</p>
</td></tr>
<tr><td><code id="as.sparse">as.sparse</code></td>
<td>

<p>Can be <code>FALSE</code>, <code>TRUE</code>, or <code>NA</code>.
</p>
<p>If <code>FALSE</code>, the block is returned as an ordinary
array (a.k.a. dense array).
</p>
<p>If <code>TRUE</code>, it's returned as a <a href="../../SparseArray/help/SparseArray.html">SparseArray</a> object.
</p>
<p>If <code>NA</code> (the default), the block is returned as an
ordinary array if <code><a href="../../S4Arrays/help/is_sparse.html">is_sparse</a>(x)</code> is <code>FALSE</code>
and as a <a href="../../SparseArray/help/SparseArray.html">SparseArray</a> object otherwise.
In other words, using <code>as.sparse=NA</code> is equivalent
to using <code>as.sparse=is_sparse(x)</code>.
This preserves sparsity and is the most efficient way to read a block.
</p>
<p>Note that when returned as a 2D <a href="../../SparseArray/help/SparseArray.html">SparseArray</a> object
with numeric or logical data, a block can easily and efficiently
be coerced to a <a href="../../Matrix/help/sparseMatrix.html">sparseMatrix</a> derivative from the
<span class="pkg">Matrix</span> package with <code>as(block, "sparseMatrix")</code>.
This will return a dgCMatrix object if <code>type(block)</code>
is <code>"double"</code> or <code>"integer"</code>, and a lgCMatrix
object if it's <code>"logical"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read_block()</code> delegates to 2 internal generic functions for
reading a block:
</p>

<ul>
<li> <p><code>read_block_as_dense</code>: used when <code>is_sparse(x)</code>
is <code>FALSE</code>.
</p>
</li>
<li> <p><code><a href="../../SparseArray/help/read_block_as_sparse.html">read_block_as_sparse</a></code> (defined in
the <span class="pkg">SparseArray</span> package): used when <code>is_sparse(x)</code>
is <code>TRUE</code>.
</p>
</li></ul>

<p>Note that these 2 internal generic functions are not meant to be
called directly by the end user. The end user should always call
the higher-level user-facing <code>read_block()</code> function instead.
</p>


<h3>Value</h3>

<p>A block of data. More precisely, the data from <code>x</code> that belongs to the
block delimited by the specified viewport.
</p>
<p>The block of data is returned either as an ordinary (dense) array
or as a <a href="../../SparseArray/help/SparseArray.html">SparseArray</a> object from the <span class="pkg">SparseArray</span>
package.
</p>
<p>Note that the returned block of data is guaranteed to have the same type
as <code>x</code> and the same dimensions as the <code>viewport</code>.
More formally, if <code>block</code> is the value returned by
<code>read_block(x, viewport)</code>, then:
</p>
<pre>    identical(type(block), type(x))</pre>
<p>and
</p>
<pre>    identical(dim(block), dim(viewport))</pre>
<p>are always <code>TRUE</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="../../S4Arrays/help/ArrayGrid.html">ArrayGrid</a> for ArrayGrid and ArrayViewport objects.
</p>
</li>
<li> <p><code><a href="../../S4Arrays/help/is_sparse.html">is_sparse</a></code> to check whether an object uses a
sparse representation of the data or not.
</p>
</li>
<li> <p><a href="../../SparseArray/help/SparseArray.html">SparseArray</a> objects implemented in the
<span class="pkg">SparseArray</span> package.
</p>
</li>
<li> <p><code>S4Arrays::<a href="../help/type.html">type</a></code> to get the type of the
elements of an array-like object.
</p>
</li>
<li><p> The <code><a href="../../SparseArray/help/read_block_as_sparse.html">read_block_as_sparse</a></code> internal
generic function defined in the <span class="pkg">SparseArray</span> package
and used by <code>read_block()</code> when <code>is_sparse(x)</code>
is <code>TRUE</code>.
</p>
</li>
<li> <p><code><a href="../../S4Arrays/help/write_block.html">write_block</a></code> to write a block of data to an
array-like object.
</p>
</li>
<li> <p><code><a href="../../DelayedArray/help/blockApply.html">blockApply</a></code> and family, in the
<span class="pkg">DelayedArray</span> package, for convenient block processing
of an array-like object.
</p>
</li>
<li> <p>dgCMatrix and lgCMatrix objects
implemented in the <span class="pkg">Matrix</span> package.
</p>
</li>
<li> <p><a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> objects implemented in the
<span class="pkg">DelayedArray</span> package.
</p>
</li>
<li> <p><a href="../../base/help/array.html">array</a> and <a href="../../base/help/matrix.html">matrix</a> objects in base R.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Please note that, although educative, the examples below are somewhat
## artificial and do not illustrate real-world usage of read_block().
## See '?RealizationSink' in the DelayedArray package for more realistic
## read_block/write_block examples.

## ---------------------------------------------------------------------
## BASIC EXAMPLE 1: READ A BLOCK FROM AN ORDINARY MATRIX (DENSE)
## ---------------------------------------------------------------------
m1 &lt;- matrix(1:30, ncol=5)
m1

## Define the viewport on 'm1' to read the data from:
block1_dim &lt;- c(4, 3)
viewport1 &lt;- ArrayViewport(dim(m1), IRanges(c(3, 2), width=block1_dim))
viewport1

## Read the block:
block1 &lt;- read_block(m1, viewport1)  # same as m1[3:6, 2:4, drop=FALSE]
block1

## Use 'as.sparse=TRUE' to read the block as sparse object:
block1b &lt;- read_block(m1, viewport1, as.sparse=TRUE)
block1b
is_sparse(block1b)  # TRUE
class(block1b)      # an SVT_SparseArray object

## Sanity checks:
stopifnot(identical(type(m1), type(block1)))
stopifnot(identical(dim(viewport1), dim(block1)))
stopifnot(identical(m1[3:6, 2:4, drop=FALSE], block1))
stopifnot(is(block1b, "SparseArray"))
stopifnot(identical(type(m1), type(block1b)))
stopifnot(identical(dim(viewport1), dim(block1b)))
stopifnot(identical(block1, as.array(block1b)))

## ---------------------------------------------------------------------
## BASIC EXAMPLE 2: READ A BLOCK FROM A SPARSE MATRIX
## ---------------------------------------------------------------------
m2 &lt;- rsparsematrix(12, 20, density=0.2,
                    rand.x=function(n) sample(25, n, replace=TRUE))
m2
is_sparse(m2)  # TRUE

## Define the viewport on 'm2' to read the data from:
block2_dim &lt;- c(2, 20)
viewport2 &lt;- ArrayViewport(dim(m2), IRanges(c(1, 1), width=block2_dim))
viewport2

## By default, read_block() preserves sparsity:
block2 &lt;- read_block(m2, viewport2)
block2
is_sparse(block2)  # TRUE
class(block2)      # an SVT_SparseArray object

## Use 'as.sparse=FALSE' to force read_block() to return an ordinary
## matrix or array:
block2b &lt;- read_block(m2, viewport2, as.sparse=FALSE)
block2b
as(block2b, "sparseMatrix")

## Sanity checks:
stopifnot(is(block2, "SparseArray"))
stopifnot(identical(type(m2), type(block2)))
stopifnot(identical(dim(viewport2), dim(block2)))
stopifnot(identical(type(m2), type(block2b)))
stopifnot(identical(dim(viewport2), dim(block2b)))
stopifnot(identical(block2b, as.array(block2)))

## ---------------------------------------------------------------------
## BASIC EXAMPLE 3: READ A BLOCK FROM A 3D ARRAY
## ---------------------------------------------------------------------
a3 &lt;- array(1:60, dim=5:3)

## Define the viewport on 'a3' to read the data from:
block3_dim &lt;- c(2, 4, 1)
viewport3 &lt;- ArrayViewport(dim(a3), IRanges(c(1, 1, 3), width=block3_dim))
viewport3

## Read the block:
block3 &lt;- read_block(a3, viewport3)  # same as a3[1:2, 1:4, 3, drop=FALSE]
block3

## Note that unlike [, read_block() never drops dimensions.

## Sanity checks:
stopifnot(identical(type(a3), type(block3)))
stopifnot(identical(dim(viewport3), dim(block3)))
stopifnot(identical(a3[1:2, 1:4, 3, drop=FALSE], block3))

## ---------------------------------------------------------------------
## BASIC EXAMPLE 4: READ AND PROCESS BLOCKS DEFINED BY A GRID
## ---------------------------------------------------------------------
a4 &lt;- array(runif(120), dim=6:4)

## Define a grid of 2x3x2 blocks on 'a4':
grid4 &lt;- RegularArrayGrid(dim(a4), spacings=c(2,3,2))
grid4
nblock &lt;- length(grid4)  # number of blocks

## Walk on the grid and print the corresponding blocks:
for (bid in seq_len(nblock)) {
    viewport &lt;- grid4[[bid]]
    block &lt;- read_block(a4, viewport)
    cat("====== Block ", bid, "/", nblock, " ======\n", sep="")
    print(block)
}

## Walk on the grid and compute the sum of each block:
block_sums &lt;- sapply(grid4,
    function(viewport) sum(read_block(a4, viewport))
)
block_sums

## Sanity checks:
stopifnot(identical(length(block_sums), nblock))
stopifnot(all.equal(sum(block_sums), sum(a4)))

## ---------------------------------------------------------------------
## THE read_block/write_block COMBO
## ---------------------------------------------------------------------
## See '?write_block' for examples that use the read_block/write_block
## combo.
</code></pre>

<hr><div style="text-align: center;">[Package <em>S4Arrays</em> version 1.10.1 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
