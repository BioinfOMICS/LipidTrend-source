<!DOCTYPE html><html><head><title>R: Write array blocks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>write_block {S4Arrays}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Write array blocks</h2>

<h3>Description</h3>

<p>Use <code>write_block</code> to write a block of data to an array-like object.
</p>
<p>Note that this function is typically used in the context of block processing
of on-disk objects (e.g. <a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> objects), often
in combination with <code><a href="../../S4Arrays/help/read_block.html">read_block</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_block(sink, viewport, block)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sink">sink</code></td>
<td>

<p>A **writable** array-like object. This is typically a
<a href="../../DelayedArray/help/RealizationSink.html">RealizationSink</a> derivative (RealizationSink
is a virtual class defined in the <span class="pkg">DelayedArray</span> package),
but not necessarily. See <code>?<a href="../../DelayedArray/help/RealizationSink.html">RealizationSink</a></code>
in the <span class="pkg">DelayedArray</span> package for more information about
RealizationSink objects.
</p>
<p>Although <code>write_block()</code> will typically be used on a RealizationSink
derivative, it can also be used on an ordinary array or other in-memory
array-like object that supports subassignment (<code>`[&lt;-`</code>), like
a <a href="../../SparseArray/help/SparseArray.html">SparseArray</a> object from the <span class="pkg">SparseArray</span>
package, or a dgCMatrix object from the <span class="pkg">Matrix</span> package.
</p>
</td></tr>
<tr><td><code id="viewport">viewport</code></td>
<td>

<p>An <a href="../../S4Arrays/help/ArrayViewport.html">ArrayViewport</a> object compatible with <code>sink</code>, that is,
such that <code>refdim(viewport)</code> is identical to <code>dim(sink)</code>.
</p>
</td></tr>
<tr><td><code id="block">block</code></td>
<td>

<p>An array-like object of the same dimensions as <code>viewport</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified array-like object <code>sink</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="../../S4Arrays/help/ArrayGrid.html">ArrayGrid</a> for ArrayGrid and ArrayViewport objects.
</p>
</li>
<li> <p><a href="../../SparseArray/help/SparseArray.html">SparseArray</a> objects implemented in the
<span class="pkg">SparseArray</span> package.
</p>
</li>
<li> <p><code><a href="../../S4Arrays/help/read_block.html">read_block</a></code> to read a block of data from an
array-like object.
</p>
</li>
<li> <p><code><a href="../../DelayedArray/help/blockApply.html">blockApply</a></code> and family, in the
<span class="pkg">DelayedArray</span> package, for convenient block processing
of an array-like object.
</p>
</li>
<li> <p><a href="../../DelayedArray/help/RealizationSink.html">RealizationSink</a> objects implemented in the
<span class="pkg">DelayedArray</span> package for more realistic <code>write_block</code>
examples.
</p>
</li>
<li> <p><a href="../../base/help/array.html">array</a> and <a href="../../base/help/matrix.html">matrix</a> objects in base R.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Please note that, although educative, the examples below are somewhat
## artificial and do not illustrate real-world usage of write_block().
## See '?RealizationSink' in the DelayedArray package for more realistic
## read_block/write_block examples.

## ---------------------------------------------------------------------
## BASIC EXAMPLE 1: WRITE A BLOCK TO AN ORDINARY MATRIX (DENSE)
## ---------------------------------------------------------------------
m1 &lt;- matrix(1:30, ncol=5)
m1

## Define the viewport on 'm1' to write the data to:
block1_dim &lt;- c(4, 3)
viewport1 &lt;- ArrayViewport(dim(m1), IRanges(c(3, 2), width=block1_dim))
viewport1

## Data to write:
block1 &lt;- read_block(m1, viewport1) + 1000L

## Write the block:
m1A &lt;- write_block(m1, viewport1, block1)
m1A

## Sanity checks:
stopifnot(identical(`[&lt;-`(m1, 3:6, 2:4, value=block1), m1A))
m1B &lt;- write_block(m1, viewport1, as(block1, "dgCMatrix"))
stopifnot(identical(m1A, m1B))

## ---------------------------------------------------------------------
## BASIC EXAMPLE 2: WRITE A BLOCK TO A SPARSE MATRIX
## ---------------------------------------------------------------------
m2 &lt;- rsparsematrix(12, 20, density=0.2,
                    rand.x=function(n) sample(25, n, replace=TRUE))
m2

## Define the viewport on 'm2' to write the data to:
block2_dim &lt;- c(2, 20)
viewport2 &lt;- ArrayViewport(dim(m2), IRanges(c(1, 1), width=block2_dim))
viewport2

## Data to write:
block2 &lt;- matrix(1001:1040, nrow=2)

## Write the block:
m2A &lt;- write_block(m2, viewport2, block2)
m2A

## Sanity checks:
stopifnot(identical(`[&lt;-`(m2, 1:2, , value=block2), m2A))
m2B &lt;- write_block(m2, viewport2, as(block2, "dgCMatrix"))
stopifnot(identical(m2A, m2B))

## ---------------------------------------------------------------------
## BASIC EXAMPLE 3: WRITE A BLOCK TO A 3D ARRAY
## ---------------------------------------------------------------------
a3 &lt;- array(1:60, dim=5:3)

## Define the viewport on 'a3' to write the data to:
block3_dim &lt;- c(2, 4, 1)
viewport3 &lt;- ArrayViewport(dim(a3), IRanges(c(1, 1, 3), width=block3_dim))
viewport3

## Data to write:
block3 &lt;- array(-(1:8), dim=block3_dim)

## Write the block:
a3A &lt;- write_block(a3, viewport3, block3)
a3A

## Sanity checks:
stopifnot(identical(`[&lt;-`(a3, 1:2, , 3, value=block3), a3A))
a3B &lt;- write_block(a3, viewport3, as(block3, "SparseArray"))
stopifnot(identical(a3A, a3B))

## ---------------------------------------------------------------------
## BASIC EXAMPLE 4: WRITE BLOCKS DEFINED BY A GRID
## ---------------------------------------------------------------------
a4 &lt;- array(NA_real_, dim=6:4)

## Define a grid of 2x3x2 blocks on 'a4':
grid4 &lt;- RegularArrayGrid(dim(a4), spacings=c(2,3,2))
grid4
nblock &lt;- length(grid4)  # number of blocks

## Walk on the grid and write blocks of random data:
for (bid in seq_len(nblock)) {
    viewport &lt;- grid4[[bid]]
    block &lt;- array(runif(length(viewport)), dim=dim(viewport))
    cat("====== Write block ", bid, "/", nblock, " ======\n", sep="")
    a4 &lt;- write_block(a4, viewport, block)
}
a4

## ---------------------------------------------------------------------
## BASIC EXAMPLE 5: READ, PROCESS, AND WRITE BLOCKS DEFINED BY TWO GRIDS
## ---------------------------------------------------------------------
## Say we have a 3D array and want to collapse its 3rd dimension by
## summing the array elements that are stacked vertically, that is, we
## want to compute the matrix 'm' obtained by doing 'sum(a[i, j, ])' for
## all valid i and j. There are several ways to do this.

## 1. Here is a solution based on apply():

collapse_3rd_dim &lt;- function(a) apply(a, MARGIN=1:2, sum)

## 2. Here is a slightly more efficient solution:

collapse_3rd_dim &lt;- function(a) {
    m &lt;- matrix(0, nrow=nrow(a), ncol=ncol(a))
    for (z in seq_len(dim(a)[[3]]))
        m &lt;- m + a[ , , z]
    m
}

## 3. And here is a block-processing solution that involves two grids,
##    one for the sink, and one for the input:

a5 &lt;- array(runif(8000), dim=c(25, 40, 8))  # input
m  &lt;- array(NA_real_, dim=dim(a5)[1:2])     # sink

## Since we're going to walk on the two grids simultaneously, read a
## block from 'a5' and write it to 'm', we need to make sure that we
## define grids that are "aligned". More precisely, the two grids must
## have the same number of viewports, and the viewports in one must
## correspond to the viewports in the other one:
m_grid  &lt;- RegularArrayGrid(dim(m),  spacings=c(10, 10))
a5_grid &lt;- RegularArrayGrid(dim(a5), spacings=c(10, 10, dim(a5)[[3]]))

## Let's check that our two grids are actually "aligned":
stopifnot(identical(length(m_grid), length(a5_grid)))
stopifnot(identical(dims(m_grid), dims(a5_grid)[ , 1:2, drop=FALSE]))

## Walk on the two grids simultaneously, and read/collapse/write blocks:
for (bid in seq_along(m_grid)) {
    ## Read block from 'a5'.
    a5_viewport &lt;- a5_grid[[bid]]
    block &lt;- read_block(a5, a5_viewport)
    ## Collapse it.
    block &lt;- collapse_3rd_dim(block)
    ## Write the collapsed block to 'm'.
    m_viewport &lt;- m_grid[[bid]]
    m &lt;- write_block(m, m_viewport, block)
}

## Sanity checks:
stopifnot(identical(dim(a5)[1:2], dim(m)))
stopifnot(identical(sum(a5), sum(m)))
stopifnot(identical(collapse_3rd_dim(a5), m))

## See '?RealizationSink' in the DelayedArray package for a more
## realistic "array collapse" example where the blocks are written
## to a RealizationSink object.
</code></pre>

<hr><div style="text-align: center;">[Package <em>S4Arrays</em> version 1.10.1 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
