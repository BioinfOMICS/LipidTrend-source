<!DOCTYPE html><html><head><title>R: Kronecker products on Array objects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script>
const macros = { "\\R": "\\textsf{R}", "\\mbox": "\\text", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css">
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>Array-kronecker-methods {S4Arrays}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Kronecker products on Array objects</h2>

<h3>Description</h3>

<p>The <span class="pkg">S4Arrays</span> package implements <code>kronecker()</code> methods
for <a href="../../S4Arrays/help/Array.html">Array</a> objects that work out-of-the-box on <a href="../../S4Arrays/help/Array.html">Array</a>
derivatives that support <code>[</code> and <code>*</code>.
</p>
<p>Note that <code>kronecker</code> is a generic function defined in the
<span class="pkg">methods</span> package but documented in the <span class="pkg">base</span> package.
See <code>?base::<a href="../../S4Arrays/help/kronecker.html">kronecker</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Array,ANY'
kronecker(X, Y, FUN="*", make.dimnames=FALSE, ...)
## S4 method for signature 'ANY,Array'
kronecker(X, Y, FUN="*", make.dimnames=FALSE, ...)
## S4 method for signature 'Array,Array'
kronecker(X, Y, FUN="*", make.dimnames=FALSE, ...)

## The workhorse behind the three above methods.
kronecker2(X, Y, FUN="*", make.dimnames=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="X">X</code>, <code id="Y">Y</code></td>
<td>

<p>Array-like objects. Alternatively <code>X</code> and/or <code>Y</code> can
be vectors, in which case they are converted to 1D-arrays with
<code>as.array()</code>.
</p>
<p>Note that <code>X</code> and <code>Y</code> are expected to have the same
number of dimensions. However, when they don't, <em>ineffective
dimensions</em> (i.e. dimensions with an extent of 1) are added to the
object with less dimensions.
</p>
<p>For the S4 methods, at least one of <code>X</code> or <code>Y</code>
must be an <a href="../../S4Arrays/help/Array.html">Array</a> derivative.
</p>
</td></tr>
<tr><td><code id="FUN">FUN</code>, <code id="make.dimnames">make.dimnames</code>, <code id="...">...</code></td>
<td>

<p>See <code>?base::<a href="../../base/help/kronecker.html">kronecker</a></code> for a description of
these arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three <code>kronecker()</code> methods listed above
delegate to <code>kronecker2()</code>, a re-implementation of
<code>base::<a href="../../S4Arrays/help/kronecker.html">kronecker</a>()</code>.
</p>
<p><code>kronecker2()</code> is semantically equivalent to
<code>base::<a href="../../S4Arrays/help/kronecker.html">kronecker</a></code>. However, unlike the latter which
calls <code>as.array()</code> on <code>X</code> and <code>Y</code> internally,
the former <em>operates natively</em> on the input objects regardless
of their internal representations, as long as they are array-like
objects that support <code>[</code> (single-bracket subsetting) and <code>*</code>.
In particular, when <code>X</code> and <code>Y</code> use the same internal
representations, the returned object will also use that representation.
In other words, the output object will have the same class as the
input objects (<em>endomorphism</em>).
</p>
<p>The <em>endomorphism</em> property is particularly important when the input
objects are sparse (e.g. <a href="../../SparseArray/help/SVT_SparseArray.html">SVT_SparseArray</a> objects
from the <span class="pkg">SparseArray</span> package) or when they use an on-disk
representation (e.g. <a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> objects from
the <span class="pkg">DelayedArray</span> package). For example, if <code>X</code> and <code>Y</code>
are <a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> objects, the returned object is
another <a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> object. Also in that case,
calling <code>kronecker2()</code> is virtually instantaneous because all the
operations that the function performs internally on <code>X</code> and
<code>Y</code> by the are delayed!
</p>


<h3>Value</h3>

<p>An array-like object with dimensions <code>dim(X) * dim(Y)</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>base::<a href="../../S4Arrays/help/kronecker.html">kronecker</a></code> in the <span class="pkg">base</span> package.
</p>
</li>
<li><p> The &quot;Kronecker product&quot; page on Wikipedia:
<a href="https://en.wikipedia.org/wiki/Kronecker_product">https://en.wikipedia.org/wiki/Kronecker_product</a>
</p>
</li>
<li><p> The <a href="../../S4Arrays/help/Array.html">Array</a> class.
</p>
</li>
<li> <p><a href="../../SparseArray/help/SparseArray.html">SparseArray</a> objects implemented in the
<span class="pkg">SparseArray</span> package.
</p>
</li>
<li> <p><a href="../../DelayedArray/help/DelayedArray.html">DelayedArray</a> objects implemented in the
<span class="pkg">DelayedArray</span> package.
</p>
</li>
<li> <p><a href="../../HDF5Array/help/TENxMatrix.html">TENxMatrix</a> objects implemented in the
<span class="pkg">HDF5Array</span> package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------------------
## SIMPLE kronecker2() EXAMPLES
## ---------------------------------------------------------------------

m1 &lt;- matrix(1:10, nrow=2)     # 2 x 5 matrix
m2 &lt;- matrix(101:106, nrow=3)  # 3 x 2 matrix
kronecker2(m1, m2)             # 6 x 10 matrix

a1 &lt;- array(1:16, dim=c(4, 2, 2))
a2 &lt;- array(1:30, dim=c(3, 5, 2))
kronecker2(a1, a2)    # 12 x 10 x 4 array

## The Kronecker product is **not** commutative:
m1 &lt;- matrix(LETTERS[1:10], nrow=2)
m2 &lt;- matrix(letters[1:6], nrow=3)
kronecker2(m1, m2, paste, sep="*")
kronecker2(m2, m1, paste, sep="*")

## Sanity checks:
stopifnot(
  identical(kronecker2(m1, m2, paste0), kronecker(m1, m2, paste0)),
  identical(kronecker2(m2, m1, paste0), kronecker(m2, m1, paste0))
)

## ---------------------------------------------------------------------
## USING kronecker() ON Array DERIVATIVES
## ---------------------------------------------------------------------
## The user should typically avoid direct calls to kronecker2() and
## stick to kronecker(). Because this is a generic function, it will
## dispatch to the appropriate method based on the classes of the input
## objects. If one of them is an Array derivative, kronecker2() will
## be called thanks to the methods defined in the S4Arrays package and
## listed in the Usage section above.

## With SparseMatrix objects (Array derivatives):
library(SparseArray)
sm1 &lt;- poissonSparseMatrix(300, 15, density=0.25)
sm2 &lt;- poissonSparseMatrix(80, 500, density=0.15)
kronecker2(sm1, sm2)  # 24000 x 7500 SparseMatrix object

## With TENxMatrix objects (DelayedArray derivatives, therefore also
## Array derivatives):
library(HDF5Array)
M1 &lt;- writeTENxMatrix(sm1)  # 300 x 15 TENxMatrix object
M2 &lt;- writeTENxMatrix(sm2)  # 80 x 500 TENxMatrix object
K &lt;- kronecker2(M1, M2)     # instantaneous! (all operations are delayed)
showtree(K)  # show delayed operations details

## ---------------------------------------------------------------------
## VERIFYING THE MIXED-PRODUCT PROPERTY (JUST FOR FUN!)
## ---------------------------------------------------------------------
## See https://en.wikipedia.org/wiki/Kronecker_product for details
## about "The mixed-product property".

## We verify the property on 4 random matrices:
A &lt;- matrix(runif(1000), ncol=40)
B &lt;- matrix(runif(800), ncol=100)
C &lt;- matrix(runif(600), nrow=40)
D &lt;- matrix(runif(5000), nrow=100)

kAB &lt;- kronecker2(A, B)
kCD &lt;- kronecker2(C, D)
kAB_x_kCD &lt;- kAB %*% kCD
A_x_C &lt;- A %*% C
B_x_D &lt;- B %*% D
stopifnot(all.equal(kAB_x_kCD, kronecker2(A_x_C, B_x_D)))

## The mixed-product property also for the element-wise product
## (Hadamard product). We verify this on 4 random arrays:
A &lt;- array(1:60, dim=5:3)
B &lt;- array(101:180, dim=c(2,10,4))
C &lt;- array(runif(60), dim=5:3)
D &lt;- array(runif(80), dim=c(2,10,4))

kAB &lt;- kronecker2(A, B)
kCD &lt;- kronecker2(C, D)
kAB_o_kCD &lt;- kAB * kCD
A_o_C &lt;- A * C
B_o_D &lt;- B * D
stopifnot(all.equal(kAB_o_kCD, kronecker2(A_o_C, B_o_D)))
</code></pre>

<hr><div style="text-align: center;">[Package <em>S4Arrays</em> version 1.10.1 <a href="00Index.html">Index</a>]</div></main>

</div>
</body></html>
